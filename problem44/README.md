# Problem 43: Sub-string divisbility

## Problem statement

<p>Pentagonal numbers are generated by the formula, P<sub><var>n</var></sub>=<var>n</var>(3<var>n</var>−1)/2. The first ten pentagonal numbers are:</p>
<p class="center">1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...</p>
<p>It can be seen that P<sub>4</sub> + P<sub>7</sub> = 22 + 70 = 92 = P<sub>8</sub>. However, their difference, 70 − 22 = 48, is not pentagonal.</p>
<p>Find the pair of pentagonal numbers, P<sub><var>j</var></sub> and P<sub><var>k</var></sub>, for which their sum and difference are pentagonal and D = |P<sub><var>k</var></sub> − P<sub><var>j</var></sub>| is minimised; what is the value of D?</p>

## Comments

I think what I want is a quick "is this pentagonal" test based on the
quadratic formula combined with a way to enumerate pairs of pentagonal
numbers in increasing order of difference. To the scratch paper!

...

From the scratch paper, it seems that I can check whether an integer *p*
is a pentagonal number by checking whether `sqrt(1 + 24*p) % 6 == 5`.
(So among other things, `1 + 24*p` must be a perfect square)

As for enumerating pairs in increasing order of difference, first off:

      ((n+k)*(3*(n+k) - 1)/2)  -  (n*(3n - 1)/2)  ==
              (k*(3k-1)/2) + 3*n*k

Therefore, I think I can construct something that iterates over
(P<sub>a</sub> - P<sub>b</sub>, a, b) in order by using the
following pieces:
- An iterator that I initialize with a `k` value and that
  produces `((k*(3k-1)/2) + 3*n*k, n, n+k)` for `n` equal
  1, 2, 3, ... (call this a `diffpair` iterator)
- A function that takes two iterators that produce things
  in order and then merges them into another iterator that
  produces things in order. (call this `mergeiterator`)
- A function called `itfunc` that takes a `k` value and produces an iterator
  that contains a `diffpair` iterator initialized with that
  `k` value and that **after** the initial result of
  `((k*(3k-1)/2) + 3*k, 1, 1+k)` produces results from
  `mergeiterator(mydiffpair, itfunc(k+1))`

...

Well that didn't work. The iterator approach got me bogged down
in mutable reference hell, and once I finally solved that by applying
`Box<>` I ran into a stack overflow exception. If you look at
the algorithm as described, that makes sense.

Instead, I wound up using a heap to iterate over pairs (n, k) so that
P<sub>n+k</sub> - P<sub>n</sub> was minimized.

Many people on the Project Euler forums seem to have been very
careless about iterating in the right order, and it doesn't seem
to have mattered.
